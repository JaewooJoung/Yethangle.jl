# src/Yethangle.jl
module Yethangle

using FreeType
using FileIO
using JSON3
using ProgressMeter
using UUIDs

# Include other files
include("types.jl")        # Defines FontMetadata, GlyphMetrics, GlyphOutline, Glyph, TTFont, YethangleFont, etc.
include("font_utils.jl")   # Defines font-related utility functions
include("glyph_utils.jl")  # Defines glyph-related utility functions

# Character set constants
const INITIAL_CONSONANTS = [
    'ᄀ', 'ᄁ', 'ᄂ', 'ᄃ', 'ᄄ', 'ᄅ', 'ᄆ', 'ᄇ', 'ᄈ', 'ᄉ', 'ᄊ', 'ᄋ',
    'ᄌ', 'ᄍ', 'ᄎ', 'ᄏ', 'ᄐ', 'ᄑ', 'ᄒ', 'ㆁ', 'ㆆ', 'ㅿ'
]

const VOWELS = [
    'ㅏ', 'ㅑ', 'ㅓ', 'ㅕ', 'ㅗ', 'ㅛ', 'ㅜ', 'ㅠ', 'ㅡ', 'ㅣ',
    'ㅐ', 'ㅒ', 'ㅔ', 'ㅖ', 'ㅘ', 'ㅙ', 'ㅚ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅢ',
    'ㆍ', 'ᆢ'
]

const FINAL_CONSONANTS = [
    'ᆨ', 'ᆩ', 'ᆪ', 'ᆫ', 'ᆬ', 'ᆭ', 'ᆮ', 'ᆯ', 'ᆰ', 'ᆱ', 'ᆲ', 'ᆳ', 'ᆴ',
    'ᆵ', 'ᆶ', 'ᆷ', 'ᆸ', 'ᆹ', 'ᆺ', 'ᆻ', 'ᆼ', 'ᆽ', 'ᆾ', 'ᆿ', 'ᇀ', 'ᇁ', 'ᇂ'
]

#=
Calculate Unicode code point for a given Hangul syllable combination.
The result is a code point in the Private Use Area (PUA) range (0xE000 to 0xF8FF).
=#
function calculate_unicode_point(initial::Char, vowel::Char, final::Union{Char, Nothing})::Int
    initial_index = findfirst(==(initial), INITIAL_CONSONANTS)
    vowel_index = findfirst(==(vowel), VOWELS)
    
    if initial_index === nothing || vowel_index === nothing
        throw(ArgumentError("Invalid initial consonant or vowel"))
    end
    
    final_idx = 0
    if final !== nothing
        final_index = findfirst(==(final), FINAL_CONSONANTS)
        if final_index === nothing
            throw(ArgumentError("Invalid final consonant"))
        end
        final_idx = final_index - 1
    end
    
    initial_idx = initial_index - 1
    vowel_idx = vowel_index - 1
    
    # Validate calculation won't overflow the PUA range
    max_point = 0xE000 + (length(INITIAL_CONSONANTS) * length(VOWELS) * length(FINAL_CONSONANTS))
    if max_point > 0xF8FF  # End of Private Use Area
        throw(ErrorException("Unicode point calculation would exceed Private Use Area"))
    end
    
    return 0xE000 + (initial_idx * length(VOWELS) * length(FINAL_CONSONANTS)) + (vowel_idx * length(FINAL_CONSONANTS)) + final_idx
end

#= 
Generate all possible Hangul syllable combinations.
=#
function generate_all_combinations(font::YethangleFont)
    combinations = Tuple{Char, Char, Union{Char, Nothing}}[]
    for initial in INITIAL_CONSONANTS
        for vowel in VOWELS
            # Add combination without final consonant
            push!(combinations, (initial, vowel, nothing))
            # Add combinations with final consonants
            for final in FINAL_CONSONANTS
                push!(combinations, (initial, vowel, final))
            end
        end
    end
    return combinations
end

#= 
Create a new font with the given name.
=#
function create_font(name::String="옛한글")::YethangleFont
    metadata = FontMetadata(
        name,
        string(FontConstants.FONT_VERSION),
        "Generated by Yethangle.jl",
        FontConstants.DEFAULT_EM_SQUARE
    )
    
    font = YethangleFont(metadata)
    
    # Add .notdef glyph at index 0
    font.glyphs['\0'] = create_notdef_glyph()
    font.glyph_indices['\0'] = 0
    font.next_glyph_id = 1
    
    return font
end

#= 
Generate font file with all syllable combinations.
=#
function generate_font(font_name::String="옛한글", output_file::String="output/yethangle.ttf")
    try
        font = create_font(font_name)
        
        println("조합 생성 중...")
        combinations = generate_all_combinations(font)
        total = length(combinations)
        println("생성할 총 조합 수: $total")
        
        # Validate total number of glyphs
        if total > FontConstants.MAX_GLYPHS
            throw(ErrorException("Too many glyphs: $total exceeds maximum of $(FontConstants.MAX_GLYPHS)"))
        end
        
        # Process combinations with progress tracking
        update_interval = max(1, total ÷ 100)  # Update every 1% of the total
        progress = Progress(total, 1, "글리프 생성 중...")
        for (i, (initial, vowel, final)) in enumerate(combinations)
            try
                if i % update_interval == 0
                    update!(progress, i)
                end
                
                glyph = create_syllable_glyph(initial, vowel, final)
                unicode_point = calculate_unicode_point(initial, vowel, final)
                font.glyphs[Char(unicode_point)] = glyph
                
            catch e
                @warn "Failed to create glyph for combination: initial=$initial, vowel=$vowel, final=$final" exception=e
                continue
            end
        end
        finish!(progress)
        
        # Generate TTF file
        println("TTF 파일 생성 중...")
        generate_ttf(font, output_file)
        println("완료: $output_file")
        
    catch e
        @error "Font generation failed" exception=e
        rethrow(e)
    end
end

# Export public interface
export FontMetadata, GlyphMetrics, GlyphOutline, Glyph, TTFont, YethangleFont
export FontConstants, FontError, EmSquareError, MetricsError, GlyphError
export create_font, generate_all_combinations, generate_font
export add_metadata!, add_glyph!, save_ttf, generate_ttf
export create_syllable_glyph, create_notdef_glyph

end # module
